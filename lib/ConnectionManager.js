"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var Apis=_interopRequireWildcard(require("./ApiInstances")),_ChainWebSocket=_interopRequireDefault(require("./ChainWebSocket"));function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}function _getRequireWildcardCache(a){if("function"!=typeof WeakMap)return null;var b=new WeakMap,c=new WeakMap;return(_getRequireWildcardCache=function(a){return a?c:b})(a)}function _interopRequireWildcard(a,b){if(!b&&a&&a.__esModule)return a;if(null===a||"object"!=typeof a&&"function"!=typeof a)return{default:a};var c=_getRequireWildcardCache(b);if(c&&c.has(a))return c.get(a);var d={},e=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var f in a)if("default"!=f&&Object.prototype.hasOwnProperty.call(a,f)){var g=e?Object.getOwnPropertyDescriptor(a,f):null;g&&(g.get||g.set)?Object.defineProperty(d,f,g):d[f]=a[f]}return d.default=a,c&&c.set(a,d),d}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}class Manager{constructor(a){var b=this;let{url:c,urls:d,autoFallback:e,closeCb:f,optionalApis:g,urlChangeCallback:h}=a;_defineProperty(this,"setCloseCb",a=>{this.closeCb=a}),_defineProperty(this,"logFailure",(a,b,c)=>{let d=c&&c.message?c.message:"";console.error(a,"Failed to connect to "+b+(d?" Error: "+JSON.stringify(d):""))}),_defineProperty(this,"_onClose",()=>{this.isConnected=!1,this.closeCb&&(this.closeCb(),this.setCloseCb(null)),this.autoFallback&&this.connectWithFallback()}),_defineProperty(this,"connect",async function(){let a=!(0<arguments.length&&arguments[0]!==void 0)||arguments[0],c=1<arguments.length&&arguments[1]!==void 0?arguments[1]:b.url;try{let d=await Apis.instance(c,a,void 0,b.optionalApis,b._onClose).init_promise;return b.url=c,b.isConnected=!0,d}catch(a){throw await Apis.close(),a}}),_defineProperty(this,"connectWithFallback",async function(){let a=!(0<arguments.length&&arguments[0]!==void 0)||arguments[0],c=1<arguments.length&&arguments[1]!==void 0?arguments[1]:b.url,d=2<arguments.length&&arguments[2]!==void 0?arguments[2]:0,e=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null,f=4<arguments.length&&arguments[4]!==void 0?arguments[4]:null;if(d>b.urls.length)return f(new Error("Tried "+d+" connections, none of which worked: "+JSON.stringify(b.urls.concat(b.url))));try{return await b.connect(a,c)}catch(c){return b.urlChangeCallback&&b.urlChangeCallback(b.urls[d]),b.connectWithFallback(a,b.urls[d],d+1,e,f)}}),_defineProperty(this,"checkConnections",async function(){let a=0<arguments.length&&arguments[0]!==void 0?arguments[0]:"",c=1<arguments.length&&arguments[1]!==void 0?arguments[1]:"",d=2<arguments.length?arguments[2]:void 0,e=3<arguments.length?arguments[3]:void 0,f={},g=b.urls.concat(b.url),h=g.map(async d=>{/* Use default timeout and no reconnecting-websocket */let e=new _ChainWebSocket.default(d,()=>{},void 0,!1);f[d]=new Date().getTime();try{await e.login(a,c);let b={[d]:new Date().getTime()-f[d]};return await e.close(),b}catch(a){return d===b.url?b.url=b.urls[0]:b.urls=b.urls.filter(b=>b!==d),void(await e.close())}});try{let a=await Promise.all(h),b=a.filter(b=>!!b).sort((c,a)=>Object.values(c)[0]-Object.values(a)[0]).reduce((b,c)=>{let a=Object.keys(c)[0];return b[a]=c[a],b},{});return console.log(`Checked ${a.length} connections, ${a.length-Object.keys(b).length} failed`),b}catch(f){return b.checkConnections(a,c,d,e)}}),this.url=c,this.urls=d.filter(b=>b!==c),this.autoFallback=e,this.closeCb=f,this.optionalApis=g||{},this.isConnected=!1,this.urlChangeCallback=h}static close(){return Apis.close()}}var _default=Manager;exports.default=_default;